import std;
/* Problems with this implementation:
only handles standard SPI
- we should have parametrized multi-line SPI
can only handle 1 exchange at a time
- we maybe want a process that wraps around this to send multiple bytes sequentially (without re-raising CS)
still needs PRS internals
*/

// are there better ways to encode these?
template<pint NCS>
deftype spi_cfg(bool cpol, cpha; enum<NCS> cs) { }
deftype spi_rw(bool read, write) { }

// N stored bits; NCS cs lines
template<pint N, NCS>
defproc spi_host(chan(spi_cfg<NCS>)? CFG; chan(spi_rw)? RW; bool! cs[NCS]; chan(int<N>)? INP; chan(int<N>)! OUTP; bool? miso; bool! mosi) {
  spi_cfg<NCS> cfg;
  spi_rw rw;
  int<N> data;
  int<std::ceil_log2(N)> counter;
  chp {

    (,i:NCS : cs[i]+),
    counter := 0,
    CFG?cfg;

    *[
      [| #CFG -> CFG?cfg |],

      RW?rw;

      [ ~rw.write -> skip
      [] rw.write -> INP?data
      ],

      cs[cfg.cs]-,

      // will this compile to the "right" implementation?
      *[ counter != N ->
        mosi := bool(data{0});
        data := data >> 1;
        data{N-1} := int(miso)
      ];

      [ ~rw.read -> skip
      [] rw.read -> OUTP!data
      ],

      counter := 0,

      cs[cfg.cs]+
    ]
  }
}
